README

#######################################
# 1. Requirement                      #
#######################################

1.1 OS and kernel
=================

Currently, the tool only supports Linux.

Tested Arch:
  x86_64

Tested OS:
  Redhat Enterprise Linux 5.4
  Ubuntu Desktop 10.10

1.2 Building essentials
=======================

GNU make version 3.81 or higher.
PIN binary instrumentation tool, latest version.
Google protobuf tool, version 2.4.1 or higher.

1.3 Target programs
===================

In general, our tool can test any x86 binary with the following
conditions:
  1) Should use dynamic linking
  2) Preferably use -fno-omit-frame-pointer when compile
  3) Preferably use pthread library for threading and synchronization


#######################################
# 2. How to build the package         #
#######################################

1) Download and install
   a) the latest PIN binary instrumentation tool
   b) the latest Google protobuf tool

2) Set environment variable PIN_HOME and PROTOBUF_HOME accordingly

3) Make the package

   $ make compiletype=debug
   (To build the debug version)

   $ make compiletype=release
   (To build the release version. Slow assertions are removed.)

#######################################
# 3. Configuration                    #
#######################################

Our tool leverages the POSIX realtime priorities. In order to change
realtime priorities on Linux, the user needs to acquire the
appropriate permission. You can check your permission using 'ulimit'.

# ulimit -a
...
scheduling priority             (-e) 40
...
real-time priority              (-r) 99
...

To grant the permission of changing realtime priorities to a user, the
root user should edit the 'limits.conf' config file as follows:

Add the following lines to the file: /etc/security/limits.conf

jieyu           hard    nice            -20
jieyu           soft    nice            -20
jieyu           hard    rtprio          99
jieyu           soft    rtprio          99


#######################################
# 4. Test a simple buggy program      #
#######################################

4.1 The simple buggy program
============================

Edit a file, named buggy.c. Its content is shown below:

--------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <assert.h>
 
unsigned NUM_THREADS = 1;
unsigned global_count = 0;
void *thread(void *);
               
int main(int argc, char *argv[]) {
  long i;
  pthread_t pthread_id[200];
  NUM_THREADS = atoi(argv[1]);

  for(i = 0; i < NUM_THREADS; i++)
    pthread_create(&pthread_id[i], NULL, thread, (void *) i);
  for(i = 0; i < NUM_THREADS; i++)
    pthread_join(pthread_id[i], NULL);

  assert(global_count==NUM_THREADS);
  return 0;
}
 
void *thread(void * num) {
  unsigned temp = global_count;
  temp++;
  global_count = temp;
  return NULL;
}

--------------------------------------------------------------------

4.2 Compile the simple buggy program
====================================

$ gcc -fno-omit-frame-pointer -g -o buggy buggy.c -lpthread

4.3 Profile runs
================

$ pin -t build-release/idiom_profiler.so -- ./buggy 2

You can run the profile runs a few times (for this example, 2 profile
runs are enough). The tool will produce a few files in the current
directory. These files store the interleaving candidates to test.

4.4 Active test runs
====================

$ pin -t build-release/idiom_scheduler.so -- ./buggy 2

You should run the active test runs in the same directory. You can run
multiple test runs using the same command. The tool
will automatically update the interleaving candidates after each test
run. Each interleaving candidate will be attempted twice by default.

For the buggy example, the bug will be triggered in just one test
runs. You will see the following messages:

[Active Scheduler] Target iroot = 3, target idiom = 1
buggy: buggy.c:20: main: Assertion `global_count==NUM_THREADS' failed.
Aborted


#######################################
# 5. Automating tests using scripts   #
#######################################

The tool is also shipped with a few scripts which can automate the
testing process (profile runs, active test runs). We still use the
same example to show how to use these scripts.

5.1 Configure
=============

The only task is to set the environment variable PIN_HOME accordingly.
Most likely, you should have already done that when you compile the
tool.

5.2 Run the script
==================

Locate the shell script 'maple' in the tool home directory. To test
your program, simply fire the following command on your console:

$ maple --- ./buggy 2

By default, the script will profile a few times (until no new iroots
is found in consecutive 3 profile runs), and then perform active test
runs for each candidate iroot (each iroot will be attempted twice).

5.3 Specify options for the script
==================================

To obtain the list of command line options for the script, use:

$ maple --help

For example, if I do not want to predict iroots for the memory
accesses from common libraries (e.g. libc), I can specify the option
'--ignore_lib' as follows:

$ maple --ignore_lib --- ./buggy 2

There are many other options available, check them using the option
'--help'.

5.4 The script mode
===================

Sometimes, the application is not suitable for running directly on the
console such as server applications. For these applications, we have a
script mode to run these applications. You need to create a very
simple python script in order to automate the testing process. Let me
show you how to write the script still using the same example above.

First, you need to create a python script, named buggy.py, in the
followint directory:

$ touch <maple_home>/script/maple/benchmark/buggy.py

The content of the script is shown as follows:
 
--------------------------------------------------------------------

from maple.core import testing

class Test(testing.CmdlineTest):
    def __init__(self, input_idx):
        testing.CmdlineTest.__init__(self, input_idx)
        self.add_input((['./buggy', '2'], (None, None, None)))

def get_test(input_idx='default'):
    return Test(input_idx)

--------------------------------------------------------------------

After that, run:

$ maple_script --help

You should be able to see 'buggy' appearing in the valid benchmarks
field:

$ maple_script --help
usage: <script> default_script [options] --- <bench name> <input index>

valid benchmarks are:
  buggy

...

Now, simply run the following command:

$ maple_script --- buggy

The script will do the same thing as that does in the cmdline mode.

